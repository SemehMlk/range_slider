import javax.net.ssl.*;
import java.security.cert.X509Certificate;
import org.springframework.http.client.reactive.ReactorClientHttpConnector;
import reactor.netty.http.client.HttpClient;
import org.springframework.web.client.RestClient;
import io.netty.handler.ssl.SslContextBuilder;

public RestClient createInsecureRestClient() {
    try {
        // Crée un TrustManager qui ignore toutes les vérifications de certificat
        TrustManager[] trustAllCertificates = new TrustManager[]{
            new X509TrustManager() {
                public X509Certificate[] getAcceptedIssuers() { return null; }
                public void checkClientTrusted(X509Certificate[] certs, String authType) {}
                public void checkServerTrusted(X509Certificate[] certs, String authType) {}
            }
        };

        // Désactive la validation SSL
        SslContext sslContext = SslContextBuilder.forClient()
            .trustManager(trustAllCertificates)
            .build();

        HttpClient httpClient = HttpClient.create()
            .secure(sslSpec -> sslSpec.sslContext(sslContext));

        return RestClient.builder()
            .requestFactory(clientHttpConnector -> new ReactorClientHttpConnector(httpClient))
            .build();
    } catch (Exception e) {
        throw new RuntimeException("Failed to create insecure RestClient", e);
    }
}
