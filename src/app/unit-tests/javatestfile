export interface FilterCriteria {
  field: string;
  operator: string;
  value: any; // Peut être { min, max }, { timeLapse, timeUnit } ou { dateValue }
  fieldType: string; // Le type de champ (DATETIME, ENUM, etc.)
  isEditable: boolean; // Détermine si le filtre est editable ou non
}


import { Component, Input, Output, EventEmitter, OnInit } from '@angular/core';
import { BehaviorSubject } from 'rxjs';
import { FilterCriteria } from './models/filter-criteria';

@Component({
  selector: 'flows-filter-sidebar',
  templateUrl: './flows-filter-sidebar.component.html',
  styleUrls: ['./flows-filter-sidebar.component.scss']
})
export class FlowsFilterSidebarComponent implements OnInit {
  @Input() set searchableFields(fields: any[]) {
    this.searchConfigs = fields;
  }

  @Output() filterChange = new EventEmitter<FilterCriteria[]>();

  public criterias: FilterCriteria[] = [];
  public searchConfigs: any[] = [];

  private filterSubject = new BehaviorSubject<FilterCriteria[]>([]);

  ngOnInit(): void {
    // Émission initiale des filtres
    this.filterSubject.subscribe((filters) => {
      this.filterChange.emit(filters);
    });
  }

  // Méthode pour ajouter un nouveau filtre
  public addFilter(field: any): void {
    // Rendre les filtres non éditables s'ils sont valides
    this.criterias.forEach(criteria => {
      if (this.isFilterValid(criteria)) {
        criteria.isEditable = false;
      }
    });

    // Ajouter un nouveau filtre
    let operator = 'EQUAL'; // Définir l'opérateur par défaut
    if (field.fieldType === 'DATETIME') {
      operator = 'BETWEEN'; // Pour le type DATETIME
    }

    this.criterias.push({
      field,
      operator,
      value: null, // Initialiser la valeur selon le type
      fieldType: field.fieldType,
      isEditable: true,
    });

    this.updateFilters();
  }

  // Méthode pour valider un filtre
  public isFilterValid(criteria: FilterCriteria): boolean {
    switch (criteria.operator) {
      case 'BETWEEN':
        return criteria.value?.min != null && criteria.value?.max != null;
      case 'IN':
      case 'NOT_IN':
        return Array.isArray(criteria.value) && criteria.value.length > 0;
      default:
        return criteria.value != null;
    }
  }

  // Méthode pour initialiser les filtres
  public initializeFilters(initialCriterias: FilterCriteria[]): void {
    initialCriterias.forEach(criteria => {
      criteria.isEditable = !this.isFilterValid(criteria); // Rend le filtre non editable si valide
      this.criterias.push(criteria);
    });
    this.updateFilters();
  }

  // Mise à jour des filtres et notification
  private updateFilters(): void {
    this.filterSubject.next(this.criterias);
  }

  // Méthode pour rendre un filtre éditable sur double-clic
  public makeFilterEditable(index: number): void {
    this.criterias.forEach((criteria, i) => {
      if (i === index) {
        criteria.isEditable = true;
      }
    });
    this.updateFilters();
  }

  // Méthode pour retirer tous les filtres
  public removeAllFilters(): void {
    this.criterias = [];
    this.updateFilters();
  }

  // Méthode pour traiter les changements de valeur
  public onFilterValueChange(criteria: FilterCriteria): void {
    this.updateFilters();
  }
}



<div class="filters-list">
  <div *ngFor="let criteria of criterias; let i = index" class="filter-item" [class.editable]="criteria.isEditable" (dblclick)="makeFilterEditable(i)">
    <div *ngIf="!criteria.isEditable">
      <flx-criteria-value [criteria]="criteria"></flx-criteria-value>
    </div>
    <div *ngIf="criteria.isEditable">
      <flx-date-type-filter *ngIf="criteria.fieldType === 'DATETIME'" 
                            [(value)]="criteria.value" 
                            [operator]="criteria.operator" 
                            (valueChange)="onFilterValueChange(criteria)">
      </flx-date-type-filter>
      <!-- Ajoutez d'autres types de champs ici -->
    </div>
  </div>
</div>

<div class="add-new-filter">
  <button mat-button (click)="addFilter(searchConfig)">Add Filter</button>
  <button mat-button (click)="removeAllFilters()">Remove All</button>
</div>


import { Component, Input, Output, EventEmitter, OnInit } from '@angular/core';

@Component({
  selector: 'flx-date-type-filter',
  templateUrl: './date-type-filter.component.html',
  styleUrls: ['./date-type-filter.component.scss']
})
export class DateTypeFilterComponent implements OnInit {
  @Input() value: any; // Peut être { min, max } pour BETWEEN, { timeLapse, timeUnit } pour ELAPSED, ou simple date pour SIMPLE DATE
  @Input() operator: string; // Définit le type d'opérateur : 'BETWEEN', 'IN_LAST_TIME_LAPSE', etc.
  @Output() valueChange = new EventEmitter<any>();

  timeLapseUnits: string[] = ['MINUTE', 'HOUR', 'DAY', 'WEEK', 'MONTH', 'YEAR']; // Exemple d'unités de temps
  valueType: 'range' | 'elapsedTime' | 'simpleDate'; // Type de valeur pour savoir quel template utiliser

  ngOnInit(): void {
    this.setValueType(); // Détermine quel type de champ afficher
  }

  // Détermine le type de champ à afficher en fonction de l'opérateur
  private setValueType(): void {
    if (this.operator === 'BETWEEN') {
      this.valueType = 'range';
      if (!this.value) this.value = { min: null, max: null };
    } else if (this.operator === 'IN_LAST_TIME_LAPSE') {
      this.valueType = 'elapsedTime';
      if (!this.value) this.value = { timeLapse: null, timeUnit: 'DAY' };
    } else {
      this.valueType = 'simpleDate';
      if (!this.value) this.value = { dateValue: null };
    }
  }

  // Méthodes pour émettre les changements de valeur
  onDateRangeChange(): void {
    this.valueChange.emit(this.value);
  }

  onElapsedTimeChange(): void {
    this.valueChange.emit(this.value);
  }

  onDateValueChange(): void {
    this.valueChange.emit(this.value);
  }
}


<!-- Pour l'opérateur BETWEEN, on affiche deux sélecteurs de date -->
<div *ngIf="valueType === 'range'" class="date-range">
  <input type="date" [(ngModel)]="value.min" (ngModelChange)="onDateRangeChange()" placeholder="Start Date" />
  <input type="date" [(ngModel)]="value.max" (ngModelChange)="onDateRangeChange()" placeholder="End Date" />
</div>

<!-- Pour l'opérateur IN_LAST_TIME_LAPSE, on affiche un input pour le timeLapse et un select pour timeUnit -->
<div *ngIf="valueType === 'elapsedTime'" class="elapsed-time">
  <input type="number" [(ngModel)]="value.timeLapse" (ngModelChange)="onElapsedTimeChange()" placeholder="Time Lapse" />
  <select [(ngModel)]="value.timeUnit" (ngModelChange)="onElapsedTimeChange()">
    <option *ngFor="let unit of timeLapseUnits" [value]="unit">{{ unit }}</option>
  </select>
</div>

<!-- Pour un simple opérateur EQUAL ou autre, on affiche un seul sélecteur de date -->
<div *ngIf="valueType === 'simpleDate'" class="single-date">
  <input type="date" [(ngModel)]="value.dateValue" (ngModelChange)="onDateValueChange()" placeholder="Select Date" />
</div>
