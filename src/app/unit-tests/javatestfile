import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.MockitoAnnotations;
import org.springframework.http.HttpStatus;
import org.springframework.http.ProblemDetail;
import org.springframework.validation.BeanPropertyBindingResult;
import org.springframework.validation.BindingResult;
import org.springframework.validation.FieldError;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.core.MethodParameter;

import javax.validation.ConstraintViolation;
import javax.validation.ConstraintViolationException;
import javax.validation.Path;
import java.util.Collections;
import java.util.HashSet;
import java.util.Set;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Mockito.mock;

class GlobalExceptionHandlerTest {

    @InjectMocks
    private GlobalExceptionHandler globalExceptionHandler;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
    }

    // 1. Test pour RuntimeException (générer ProblemDetail)
    @Test
    void handleRuntimeException_ShouldReturnProblemDetail() {
        // GIVEN: Une RuntimeException est lancée
        RuntimeException exception = new RuntimeException("Unexpected error occurred");

        // WHEN: La méthode handleRuntimeException est appelée
        ProblemDetail problemDetail = globalExceptionHandler.handleRuntimeException(exception);

        // THEN: Le ProblemDetail doit contenir les bons détails
        assertThat(problemDetail).isNotNull();
        assertThat(problemDetail.getStatus()).isEqualTo(HttpStatus.INTERNAL_SERVER_ERROR.value());
        assertThat(problemDetail.getTitle()).isEqualTo("Unexpected Error");
        assertThat(problemDetail.getDetail()).isEqualTo("Unexpected error occurred");
    }

    // 2. Test pour ConstraintViolationException (générer ProblemDetail)
    @Test
    void handleConstraintViolationException_ShouldReturnProblemDetail() {
        // GIVEN: Une ConstraintViolationException avec une violation de contrainte
        ConstraintViolation<?> violation = createMockConstraintViolation("name", "must not be null");
        Set<ConstraintViolation<?>> violations = new HashSet<>(Collections.singletonList(violation));
        ConstraintViolationException exception = new ConstraintViolationException(violations);

        // WHEN: La méthode handleConstraintViolationException est appelée
        ProblemDetail problemDetail = globalExceptionHandler.handleConstraintViolationException(exception);

        // THEN: Le ProblemDetail doit contenir les bons détails
        assertThat(problemDetail).isNotNull();
        assertThat(problemDetail.getStatus()).isEqualTo(HttpStatus.BAD_REQUEST.value());
        assertThat(problemDetail.getTitle()).isEqualTo("Validation Error");
        assertThat(problemDetail.getDetail()).isEqualTo("Constraint violation occurred");

        // Vérifier que le champ d'erreurs contient la bonne information
        assertThat(problemDetail.getProperties().get("errors")).asList().contains("Field 'name' must not be null");
    }

    // 3. Test pour MethodArgumentNotValidException (générer ProblemDetail)
    @Test
    void handleMethodArgumentNotValidException_ShouldReturnProblemDetail() {
        // GIVEN: Une MethodArgumentNotValidException simulée
        MethodArgumentNotValidException exception = mockMethodArgumentNotValidException("email", "must be a valid email");

        // WHEN: La méthode handleMethodArgumentNotValidException est appelée
        ProblemDetail problemDetail = globalExceptionHandler.handleMethodArgumentNotValidException(exception);

        // THEN: Le ProblemDetail doit contenir les bons détails
        assertThat(problemDetail).isNotNull();
        assertThat(problemDetail.getStatus()).isEqualTo(HttpStatus.BAD_REQUEST.value());
        assertThat(problemDetail.getTitle()).isEqualTo("Validation Error");
        assertThat(problemDetail.getDetail()).isEqualTo("Validation failed");

        // Vérifier que le champ d'erreurs contient la bonne information
        assertThat(problemDetail.getProperties().get("errors")).asList().contains("Field 'email' must be a valid email");
    }

    // Méthodes utilitaires pour simuler les violations de contrainte et les erreurs de validation

    private ConstraintViolation<?> createMockConstraintViolation(String field, String message) {
        ConstraintViolation<?> violation = mock(ConstraintViolation.class);
        
        // Simuler le Path (chemin de propriété) en fonction du champ
        Path mockPath = mock(Path.class);
        when(mockPath.toString()).thenReturn(field); // Le Path converti en chaîne sera le nom du champ
        when(violation.getPropertyPath()).thenReturn(mockPath);
        when(violation.getMessage()).thenReturn(message);

        return violation;
    }

    private MethodArgumentNotValidException mockMethodArgumentNotValidException(String field, String message) {
        // Simuler un objet MethodArgumentNotValidException
        FieldError fieldError = new FieldError("objectName", field, message);
        BindingResult bindingResult = new BeanPropertyBindingResult(new Object(), "objectName");
        bindingResult.addError(fieldError);
        return new MethodArgumentNotValidException(new MethodParameter(this.getClass().getConstructors()[0], 0), bindingResult);
    }
}
